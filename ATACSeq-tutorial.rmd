---
title : "ATAC-Seq Example"
author : "Délara Sabéran-Djoneidi, Anne-Laure Schang, Kate Wooley-Allen, Sascha Ott"
output : html_document
---

## Intro and general description

This document aims to be a detailled example of an ATAC-Seq analysis used in a reasearch context. The goal here is to help you draft your own experiments from this perticular base, by walking you through the steps we took and by pointing out the parts were the specificity of your experimental set will ask for some tinkering.


## Load Conda environment

In order to be sure to have the appropriate tools to run this analysis, we provide a conda environment summarising them. to use it, please download [conda](https://docs.conda.io/projects/conda/en/latest/user-guide/install/download.html) and run the following line.
```{bash startup-conda-environment, eval=FALSE, results="hide"}
conda env create -f conda_environment.yml
```

## First Quality control
In order to see how much the pre-processing improves the data, it is good practice to look at various statistics on the raw dataset. FastQC provides a good summary of those.

```{bash fastQC-raw, eval=FALSE, results="hide"}
fastqc -o output/stats/raw_fastQC/ data/raw_reads/3_S3_R1_001.fastq.gz
fastqc -o output/stats/raw_fastQC/ data/raw_reads/3_S3_R2_001.fastq.gz
```

If you have multiple samples, multiQC is a good way to look at the global quality over your samples.

```{bash multiQC-raw, eval=FALSE, results="hide"}
multiqc output/stats/raw_fastQC
mv multiqc_data/ output/stats/raw_fastQC
mv multiqc_report.html output/stats/raw_fastQC
```
## Trimming

The fastq files are trimmed using Trimmomatic v0.39 to remove any adapter sequences in the reads caused by read through associated with DNA fragments shorter in size than the read length being sequenced.

This particular step need to be adapted depending on your exact data and need. We found these options to be the most efficient in the case of ATAC-Seq. If you want to know more we encourage you to read the [documentation](http://www.usadellab.org/cms/uploads/supplementary/Trimmomatic/TrimmomaticManual_V0.32.pdf) of the Trimmomatic tool in order to find the best possible use for your case.

```{bash trimmomatic, eval=FALSE, results="hide"}
trimmomatic PE -threads 2 data/raw_reads/3_S3_R1_001.fastq.gz data/raw_reads/3_S3_R2_001.fastq.gz output/trimmed_files/3_S3_R1_trimmed.fastq output/trimmed_files/3_S3_R1_trimmed_unpaired.fastq output/trimmed_files/3_S3_R2_trimmed.fastq output/trimmed_files/3_S3_R2_trimmed_unpaired.fastq ILLUMINACLIP:data/adapters/NexteraPE-PE.fa:2:30:10:1:true TRAILING:3 SLIDINGWINDOW:4:15
```

## Alignement

This step must also be adapted to your particular experiment, namely the genomes used may vary and the aligner used as well as the alignment options can be otpimised.

In our case, alignment is performed by bowtie2.4.4

### Bowtie2 Index

In order to align reads to genomes and particular cellular compartments (i.e. mithochodria), it is necessary to build a bowtie index for each of them and potential cofounders. In the end, only the reads mapping solely to the target of interests will be saved, which in our case means that the mithochondrial hits will be removed.

Bowtie2 necessitate and index to be build before alignment can be done. By default, the exact method used is choosen depending on the specificities of the machine doing the computation, please read the [documentation of bowtie2-build](http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml#the-bowtie2-build-indexer) for further informations, and be carefull when repeating a study on different machines.

If you already have a bowtie index built for this type of alignment, this step can be skipped.

In our particular case, the raw fasta files used are from the GRCm38/mm10 genome[here](http://hgdownload.cse.ucsc.edu/goldenPath/mm10/chromosomes/). The exact build we used is Genome Reference Consortium Mouse Build 38 (GCA_000001635.2)

```{bash bowtie2-index,  eval=FALSE, results="hide"}
bowtie2-build chr1.fa,chr2.fa,chr3.fa,chr4.fa,chr5.fa,chr6.fa,chr7.fa,chr8.fa,chr9.fa,chr10.fa,chr11.fa,chr12.fa,chr13.fa,chr14.fa,chr15.fa,chr16.fa,chr17.fa,chr18.fa,chr19.fa mouse_vn_chrN

bowtie2-build chrM.fa mouse_vn_chrM

```

### Alignement

#### Removal of Mitochondrial DNA

Let's breakdown the various options used

* `-p 4` We are using 4 threads for alignement. This option can also be accessed via `--threads`
* `-X 2000` The maximum fragment length accepted between paired end. This number should be adapted depending on your sequencing protocol.
* `--very-sensitive` preset option corresponding to `-D 20 -R 3 -N 0 -L 20 -i S,1,0.50`
* `-x` shows bowtie index
*  `-1 and -2` The input fastq files in the case of paired end alignment
*  `-S` File in which to write the output SAM file of the aligned reads. This file will not be usefull to us later, but printing it allows us to use less memory
*  `--un-conc` We only keep pairs that DIDn't aligned on mitochondrial genome

for more informations and option, you can run `bowtie2 --help`

```{bash mitochondria-removind, eval=FALSE, results="hide"}
bowtie2 -p 4 -X 2000 --very-sensitive -x data/genomes/mm10/mouse_vn_chrM -1 output/trimmed_files/3_S3_R1_trimmed.fastq -2 output/trimmed_files/3_S3_R2_trimmed.fastq -S temp_files/3_S3_tempM.sam --un-conc temp_files/3_S3_fastq
```

This command also generate some files that must be deleted, namely `temp_files/3_S3_tempM.sam`, we still keep it as an output because removing it makes the alignment much more memory heavy.

#### Alignment on chromosomal genome

Bowtie2 ask files to be compressed before alignment, so we have to zip the files. We also remove the sam files that

```{bash zipping-files, eval=FALSE, results="hide"}
gzip temp_files/3_S3_fastq.1 temp_files/3_S3_fastq.2
rm temp_files/3_S3_tempM.sam
```

We align on the chromosomal genome, in a very similar maner as the previous alignment

```{bash aligning-non-mitochodrial, eval=FALSE, results="hide" }
bowtie2 -p 4 -X 2000 --very-sensitive -x data/genomes/mm10/mouse_vn_chrN -1 temp_files/3_S3_fastq.1.gz -2 temp_files/3_S3_fastq.2.gz -S output/aligned_files/3_S3_aligned.sam
```

```{bash removing-temp-files, eval=FALSE, results="hide"}
rm temp_files/3_S3_fastq.*
```

Change of type of file, we want the sam output to be made as a sorted and indexed bam files.

```{bash sam-to-bam, eval=FALSE, results="hide"}
samtools view -b --threads 3 output/aligned_files/3_S3_aligned.sam -b -o output/aligned_files/3_S3_aligned_unsorted.bam
```

Sorting the bam file

```{bash sorting-and-indexing-bam-outputs, eval=FALSE, results="hide"}
samtools sort output/aligned_files/3_S3_aligned_unsorted.bam -o output/aligned_files/3_S3_aligned_sorted.bam
samtools index output/aligned_files/3_S3_aligned_sorted.bam
```

## Quality Controls and Filters

The various outputs of this part, located in `output/stats/` must be studied to see wether something has gone wrong up with the alignment, even though trouble at the alignment step can be caused by an uncatched problem in the earlier steps. What to do when you have an unexpected behaviour will very much depend on your experiment.

### SAMtools flags
SAMtools flag are a way SAMtools trackes several information about a read, such as wether it is paired. Here we check the repartition of those flags within our sample.

The [wikipedia page](https://en.wikipedia.org/wiki/SAM_(file_format)) about sam files does explicit the meaning of each Samtools flag, but know that the flag corresponding to a properly aligned pair of read is 2.

```{bash counting-sam-flags, eval=FALSE, results="hide"}
samtools view output/aligned_files/3_S3_aligned_sorted.bam |  awk '{print $2}' | sort -n | uniq -c | sed 's/^ *//g' > output/stats/3_S3_aligned_samflags.txt
```

### Samtools MAPQ score
The MAPQ score is related to the probability that a particular read is misaligned. with the higher the mapq, the lower that particular chances is. In our experiment we used a particular threshold of 22, corresponding to a probability of misalignment of 10<sup>-12</sup>
Let's create the MAPQ score distribution by using Samtools for reads that have the flags that correponds to 2.

```{bash MAPQ-score-computation, eval=FALSE, results="hide"}
samtools view -f2 output/aligned_files/3_S3_aligned_sorted.bam | awk '{print $5}' | sort -n | uniq -c | sed 's/^ *//g'  > output/stats/3_S3_aligned_mapq.txt
```

### Template length
Let's execute a filter on FLAGs and MAPQ quality with the used of -f and -q and observe the Template Length (space between pair of reads)

```{bash template-length-computation, eval=FALSE, results="hide"}
samtools view -f2 -q22 output/aligned_files/3_S3_aligned_sorted.bam | cut -f 9| sed 's/^-//' | sort -n | uniq -c |sed  's/^ *//g' > output/stats/3_S3_aligned_is_summary.txt
```

### Filter base on the quality scores threshold you choose
```{bash filtering, eval=FALSE, results="hide"}
samtools view -f2 -q22 -b output/aligned_files/3_S3_aligned_sorted.bam > output/aligned_filtered/3_S3_aligned_filtered.bam
```

### fastQC - general quality check
```{bash fastQC, eval=FALSE, results="hide"}
fastqc -o output/stats/fastQC/ output/aligned_filtered/3_S3_aligned_filtered.bam
```

Same as before, if you are treating several files at once, multiQC can be a good way to check wether the quality vary depending on each sample/condition, which might affect results down the line.

## Peaks calling
For calling the peaks of the ATAC-Seq, pooling the reads of similar samples together can make peak calling more efficient, you can do it in the command line of macs2. If you have several different conditions that you want to compare, keep them seperated and create one file per condition.

We use macs2 for the calling of the ATAC-Seq peaks.

This part might need to be adapted to your particular case, so let's break down the various arguments
* `-t output/aligned_filtered/merged_ctrl.bam` name of the file (or files) on wich to do the peak calling. If you input seveal files, they will be pulled together into a single callpeak file.
* `-f BAM` Type of the output file desired
* `g 1.87e9` Effective length of the genome. This will need to be adapted if you are working on non-mouse DNA or you includes more chromosomes than we did (X & Y)
* `-q 0.05` minimum q-value for report of the peaks
* `-n output/ATAC_Seq_peaks/merged_ctrl` base name of the output, several type of files, containing a variety of informations will be generated

```{bash peak-calling, eval=FALSE, results="hide"}
macs2 callpeak -t output/aligned_filtered/2_S2_aligned_filtered.bam output/aligned_filtered/3_S3_aligned_filtered.bam -f BAM -g 1.87e9 -q 0.05 -n output/ATAC_Seq_peaks/merged_ctrl
```

### Mask regions
Some peks might be in regions were informations is in fact, a bit lacking. we remove the corresponding peaks.

The file we use can be found [here](http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/mm10-mouse/mm10.blacklist.bed.gz), you should adapt this file to your current project.

```{bash mask-regions, eval=FALSE, results="hide"}
bedtools subtract -A -a output/ATAC_Seq_peaks/merged_ctrl_summits.bed -b data/blacklist/mm10.blacklist.bed > output/ATAC_Seq_ctrl_summits_BL.bed
```

### Per sample informations
If you want to determine exactly the number of reads from a perticular sample in each peak, you can use bedtools coverage

```{bash bedtools-coverage, eval=FALSE, results="hide"}
bedtools coverage -a output/ATAC_Seq_ctrl_summits_BL.bed -b output/aligned_filtered/3_S3_aligned_filtered.bam > output/coverage_per_samples/coverage_S3.bed
```
## Conclusion
And here you are ! You now have both you called ATAC-Seq peaks and the number of read which contributed in each sample. You can now use this data to compute whatever strikes your fancy.
